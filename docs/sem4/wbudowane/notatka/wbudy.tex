\documentclass[11pt]{article}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

\graphicspath{{./img}}

\definecolor{comment}{RGB}{0,128,0} % dark green
\definecolor{string}{RGB}{255,0,0}  % red
\definecolor{keyword}{RGB}{0,0,255} % blue
\lstset{language=C} 

\lstdefinestyle{mystyle}{
    commentstyle=\color{comment},
	stringstyle=\color{string},
	keywordstyle=\color{keyword},
	basicstyle=\footnotesize\ttfamily,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	frame=lines,
	breaklines=true,
	prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	showstringspaces=false,
	upquote=true,
	tabsize=2,
}

\lstset{style=mystyle}


\title{Wbudy do budy}
\author{Dawid Gradowski (puckmoment na dc)}
\date{Luty 2025}
\begin{document}
\maketitle
\renewcommand\contentsname{Spis treści}
\tableofcontents
\newpage
\section{Prolog}
Notatki robione w oparciu o projekt, który robiłem sam na zajęciach (Licznik jak coś).

\begin{table}[H]
    \centering
    \label{tab:tab1}
    \begin{tabular}{ |c|c|c| }
        \hline
        \multicolumn{3}{|c|}{Komponenciki}\\
        \hline
        Płytka & LPC1768/9 & \href{https://dgradowski.github.io/Notes-page/docs/sem4/wbudowane/notatka/docs/Schemat%20ver%20B%20(z%20portem%20USB%20typu%20A).pdf}{Schemat} \\ 
        \hline
        Ekran OLED & Rodzaj & Intrukcja \\
        \hline
        Termometr & LM75 & \href{https://dgradowski.github.io/Notes-page/docs/sem4/wbudowane/notatka/docs/LM75.pdf}{Instrukcja} \\
        \hline  
    \end{tabular}
    \caption{Używane urządzenia z przydatnymi dokumentami}
\end{table}
\section{GPIO}
\subsection{Informacje ogólne}
\textbf{GPIO} (General Purpose Input/Output) jest interfejsem, który 
możemy wykorzystać zarówno jako wejście jak i wyjście. To jak zachowuje się 
ten interfejs zależne jest od stanu Enable Line. Jeśli stan Enable Line jest
1 to interfejs robi za wejście, a jeśli 0 to robi za wyjście.

Płytka LPC1768 ma 5 portów (oznaczone od 0 do 4) i każdemu z nich
odpowiadają 4 rejestry 32 bitowe. Rejestry te w pliku oraz w programie możemy
odnaleźć pod nazwami:
\begin{itemize}
    \item \textbf{FIOPIN} - odczytywanie wartości na pinach
    \item \textbf{FIOSET} - ustawianie wartości 1 na pinach (ustawionych na output)
    \item \textbf{FIOCLR} - zerowanie wartości na pinach (ustawionych na output)
    \item \textbf{FIODIR} - ustalanie kierunku pinu (0: wejście| 1: wyjście)
\end{itemize}
Oznaczenie FIO oznacza Fast Input/Output, czyli IO (Input/Output) tylko szybsze
(tak przeczytałem na forum to nie żart). Teraz trochę jak korzystać z tych rejestrów w praktyce.
Mimo, że rejestry są 32 bitowe w przykładzie będę operował na pierwszych 4 bitach
bo nie chce mi się tyle pisać.
Na początku uznajmy, że wszystkie bity w rejestrach są ustawione na LOW (czyli 0).
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Rejestr & 3 & 2 & 1 & 0 \\ \hline
        FIOPIN & 0 & 0 & 0 & 0 \\ \hline
        FIOSET & 0 & 0 & 0 & 0 \\ \hline
        FIOCLR & 0 & 0 & 0 & 0 \\ \hline
        FIODIR & 0 & 0 & 0 & 0 \\ \hline
    \end{tabular}
\end{table}
Interfejs taki ma 32 piny i w tym momencie są ustawione na wejście. Urządzenie więc
nie może tym interfejsem wysyłać sygnału. Załóżmy, że jakieś urządzenie jest podłączone
do pinu oznaczonego numerem 3 i nadaje sygnał wysoki (1). Wtedy nasza tabelka będzie wyglądała tak:
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Rejestr & 3 & 2 & 1 & 0 \\ \hline
        FIOPIN & 1 & 0 & 0 & 0 \\ \hline
        FIOSET & 0 & 0 & 0 & 0 \\ \hline
        FIOCLR & 0 & 0 & 0 & 0 \\ \hline
        FIODIR & 0 & 0 & 0 & 0 \\ \hline
    \end{tabular}
\end{table}
Jako iż wszystkie bity w FIODIR są ustawione na 0, to żaden z naszych pinów nie jest
wyjściem więc nie możemy zmieniać wartości na pinach. Aby zmienić wartość na konkretnym bicie
możemu użyć następującej funkcji:

\begin{lstlisting}
void GPIO_SetDir(uint8_t port, uint32_t bitValue, uint8_t dir)
{
	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(port);

	if (pGPIO != NULL) {
		// Enable Output
		if (dir) {
			pGPIO->FIODIR |= bitValue;
		}
		// Enable Input
		else {
			pGPIO->FIODIR &= ~bitValue;
		}
	}
}
\end{lstlisting}
\newpage
Jeśli chcielibyśmy na przykład używać pinu 2 jako wyjścia to wartość binarna
w rejestrze FIODIR musi wyglądać następująco $0100$ co jest równe 4 w dziesiętnym.
Z tą wiedzą wiemy, że bit ten możemy zmienić wywołująć funkcję na jeden z poniższych sposobów:

\begin{lstlisting}[language=c]
GPIO_SetDir(0, (1 << 2), 1); // preferowany
GPIO_SetDir(0, 0x4, 1);
GPIO_SetDir(0, 4, 1);
\end{lstlisting}
Po wywołaniu funkcji nasze rejestry będą wyglądały następująco:
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Rejestr & 3 & 2 & 1 & 0 \\ \hline
        FIOPIN & 1 & 0 & 0 & 0 \\ \hline
        FIOSET & 0 & 0 & 0 & 0 \\ \hline
        FIOCLR & 0 & 0 & 0 & 0 \\ \hline
        FIODIR & 0 & 1 & 0 & 0 \\ \hline
    \end{tabular}
\end{table}
Teraz możemy zmienić wartość bitu 2 w rejestrze FIOPIN, nie możemy tego jednak zrobić
bezpośrednio. Aby zmienić wartość na pinie oznaczonym numerem 2 naszego interfejsu
musimy wykorzystać rejestry \textbf{FIOSET} i \textbf{FIOCLR}. Aby zmienić wartość
w tych 2 rejestrach możemy wykorzystać poniższe 2 funkcje:
\begin{lstlisting}[language=c]
void GPIO_SetValue(uint8_t portNum, uint32_t bitValue)
{
    LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);

    if (pGPIO != NULL) {
        pGPIO->FIOSET = bitValue;
    }
}

void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue)
{
	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);

	if (pGPIO != NULL) {
		pGPIO->FIOCLR = bitValue;
	}
}
\end{lstlisting}
Te 2 rejestry i funkcje działają w sposób bardzo podobny. Obydwa odpowiadają za zmiane
wartości w rejestrze FIOPIN. FIOSET ustawia wartość na 1, FIOCLR ustawia wartość na 0.
Obydwa rejestry po zmianie bitu w rejestrze FIOPIN od razu są zerowane. A więc by zmieniać
wartość pinu 2, trzeba wywołać metodę w taki sposób:
\begin{lstlisting}[language=c]
GPIO_SetValue(0, (1 << 2)); // preferowany
GPIO_SetValue(0, 0x4);
GPIO_SetValue(0, 4);
\end{lstlisting}
Po wykonaniu tej funkcji wartości w rejestrach będą wyglądały następująco:
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Rejestr & 3 & 2 & 1 & 0 \\ \hline
        FIOPIN & 1 & 0 & 0 & 0 \\ \hline
        FIOSET & 0 & 1 & 0 & 0 \\ \hline
        FIOCLR & 0 & 0 & 0 & 0 \\ \hline
        FIODIR & 0 & 1 & 0 & 0 \\ \hline
    \end{tabular}
\end{table}
I od razu zostanie zmienione na
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Rejestr & 3 & 2 & 1 & 0 \\ \hline
        FIOPIN & 1 & 1 & 0 & 0 \\ \hline
        FIOSET & 0 & 0 & 0 & 0 \\ \hline
        FIOCLR & 0 & 0 & 0 & 0 \\ \hline
        FIODIR & 0 & 1 & 0 & 0 \\ \hline
    \end{tabular}
\end{table}
Wartość pinu zostanie zmieniona praktycznie natychmiast, według czatu GPT zazwyczaj w 1 lub 2
cyklach CPU, dlatego od razu po zmianie można odczytywać wartość w rejestrze FIOPIN oraz
nie ma sensu odczytywać wartości z rejestrów FIOSET i FIOCLR bo w większości przypadków
będą one równe 0. Metoda FIOCLR działa w ten sam sposób więc nie będę jej tłumaczył.
Zarówno FIOSET jak i FIOCLR nie zadziałają na piny, dla których odpowiadające im wartości
w rejestrze FIODIR są równe 0.

Aby odczytać wartości z rejestru FIOPIN należy użyć następującej funkcji:
\begin{lstlisting}[language=c]
uint32_t GPIO_ReadValue(uint8_t portNum)
{
	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);

	if (pGPIO != NULL) {
		return pGPIO->FIOPIN;
	}

	return (0);
}
\end{lstlisting}
\newpage
Dana funkcja odczytuje jednak całą wartość rejestru a nie pojedynczego bitu.
Jęśli chcemy napisać warunek zależny od tego czy mamy na bicie 3 wartość niską bądź
wysoką, to możemy to napisać na parę sposobów:

\begin{lstlisting}[language=c]
// preferowane
if if ((GPIO_ReadValue(0) & (1 << 3)) == 0) {
    // niski sygnal
} else {
    // wysoki sygnal
}

if (((GPIO_ReadValue(0) >> 3) & 0x01) == 0) {
    // niski sygnal
} else {
    // wysoki sygnal
}

if if ((GPIO_ReadValue(0) & 8) == 0) {
    // niski sygnal
} else {
    // wysoki sygnal
}
\end{lstlisting}
\subsection{Guziczki}
W poprzedniej sekcji wytłumaczyłem jak operować na rejestrach. Teraz czas na
użycie tej wiedzy w praktyce. W przypadku płytki LPC1768 mamy 3 zwykłe przyciski 
(2 z nich mają swoje przeznaczenie w samym działaniu płytki i nie powinniśmy 
zmieniać ich zastosowania (Wakeup i Reset))
i joystick, który wysyła sygnał na 5 różnych pinów (4 strony + wciśnięcie). W 
\hyperref[tab:tab1]{schemacie płytki zamieszczonym w tabeli 1} na stronie 6 podpisanej
jako Direct Digital IO peripherals. Nasz przycisk, który możemy wykorzystać wygląda 
w schemacie następująco:

\begin{figure}[H]
\includegraphics[width=\textwidth]{GPIO_btn.png}
\caption{\label Schemat przycisku SW3/Bootloader Enable}
\end{figure}

Wiemy, który przycisk chcemy wykorzystać patrząc na schemat. Jak teraz znaleźć go na
samej płytce? Wszystkie przyciski są bezpośrednio podpisane na płytce, więc musimy znaleźć
słowo klucz obok przycisku. Te słowa to SW3, GPIO\textunderscore 37 lub BL\textunderscore EN.

Jeśli widzimy przycisk na płytce i jesteśmy w gotowości by go przycisnąć to pozostało
nam tylko zaprogramować funkcjonalności, ale by to zrobić potrzebny jest nam adres
rejestru na który wpływa ten przycisk. Aby to odkryć znów będzie potrzebny schemat
płytki z \hyperref[tab:tab1]{tabeli 1} tylko tym razem strona 2. Na stronie drugiej
odszukujemy \textbf{BL\textunderscore EN} albo \textbf{GPIO\textunderscore 37}.
Akurat obydwa te oznaczenia są po lewej stronie więc na tej samej wysokości szukamy
komórki tabeli w kolumnie opisanej nazwą naszej płytki. Na tej samej wysokości co 
oznaczenie BL\textunderscore EN jest komórka w której mamy napisane \textbf{P0.4}.
Rozbijmy sobie to oznaczenie:
\begin{itemize}
    \item \textbf{P0} - port 0 (numerowany od 0)
    \item \textbf{4} - pin 4 (numerowany od 0)
\end{itemize}
GPIO\textunderscore 37 wskazuje też inny adres ale szczerze to nie sprawdzałem czy 
przycisk też zmienia pin na tym adresie, a jeśli nie to dlaczego ale chuj w to.

Mamy już w zasięgu palca nasz przycisk gotowy do wciśnięcia, znamy już adres na który
dany przycisk wpływa, pozostało tylko zaprogramować jakąś funkcjonalność. 
Przyciski jeśli chodzi o nadawany sygnał są bardzo nieintuicyjne, ponieważ niewciśnięty
przycisk daje na wyjściu 1, a wciśnięty daje 0. 
\newpage
W instrukcji warunkowej możemy przycisków użyć w następujący sposób.
\begin{lstlisting}
if ((GPIO_ReadValue(0) & (1 << 4)) == 0) {
    // przycisk wcisniety
} else {
    // przycisk nie wcisniety
}

if ((GPIO_ReadValue(0) & (1 << 4)) > 0) {
    // przycisk nie wcisniety
} else {
    // przycisk wcisniety
}
\end{lstlisting}
\textbf{UWAGA. Trzeba pamiętać, że wartość FIODIR odpowiadający pinowi na który
przycisk nadaje musi być ustawiona na 0. W innym wypadku pin nie będzie odbierał sygnału
z przycisku.}

\section{SPI}
\subsection{Informacje ogólne}
SPI jest szeregowym interfejsem urządzeń peryferyjnych. Jest nazywany
protokołem master-slave. Za mastera uznaje się kontroler i jest on zawsze
jeden a funkcję slave pełni urządzenie peryfejryne, które musi być jedno bądź więcej.
Każde połączenie między masterem a slavem ma do 4 kabli, które są odpowiedzialne
za 4 różne sygnały logiczne (logic signals). Te sygnały to:
\begin{itemize}
    \item {
        \textbf{CS / SS} (Chip Select lub Slave Select) - odpowiada za wybór 
        urządzenia do komunikacji
    }
    \item {
        \textbf{SCLK} (Synchronous Clock) - odpowiada za synchronizacje i timing(?)
    }
    \item {
        \textbf{MOSI} (Master Out Slave In) - dane przesyłane
        przez mastera
    }
    \item {
        \textbf{MISO} (Master In Slave Out) - dane odbierane przez
        mastera
    }
\end{itemize}


\subsection{Wyświetlacz}
\subsection{Zapis na kartę pamięci}

\section{I$^2$C}
\subsection{Czujnik natężenia światła}
\subsection{Termometr}
W przypadku termomemetru LM75 adres jest ustalany następująco:
\begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
         & & & & $A_2$ & $A_1$ & $A_0$\\
        \hline
        1& 0& 0& 1& X & X & X\\
        \hline
    \end{tabular}
\end{center}
Pierwsze 4 bity są odczytane z instrukcji. Bity oznaczone $A_x$ są ustalane
zależnie od termometra na podstawie lutowania. Jeśli $A_x$ jest przylutowany
do gruntu (ground) to w adresie mamy 0, a jeśli do $+V_S$ to 1.
\section{RTC}
\end{document}